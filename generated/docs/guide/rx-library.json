{
  "id": "guide/rx-library",
  "title": "The RxJS library",
  "contents": "\n<div class=\"content\">\n<h1 id=\"the-rxjs-library\">The RxJS library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1>\n<p>Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code (<a href=\"http://reactivex.io/rxjs/\">RxJS Docs</a>).</p>\n<p>Reactive programming는 데이터 steream 과 변화의 전파에 대한 비동기 프로그램 패러다임이다(<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>). RXJS(자바스크립트를 위한 리액티브 익스텐션들) 는  비동기와 callback-기반  의  코드를 더 쉽게 구성하는 observables 을 사용하는 리액티브 프로그래밍을 위한 라이브러리 입니다. (<a href=\"http://reactivex.io/rxjs/\">RxJS Docs</a>).</p>\n<p>RxJS provides an implementation of the <code>Observable</code> type, which is needed until the type becomes part of the language and until browsers support it. The library also provides utility functions for creating and working with observables. These utility functions can be used for:\nRxJS 는 <code>Observable</code> 타입의 구현이 언어의 한 부분으로 되거나 브라우져에서 이것을 지원될때까지 제공한다. 또한 라이브러리는 observables을 가지고 생성하거나 도작하는 유틸리티 함수들을 제공한다. 그러한 유틸리티 함수들은 다음 위해서 사용될 수 있다.</p>\n<ul>\n<li>\n<p>Converting existing code for async operations into observables</p>\n</li>\n<li>\n<p>존재하는 코드를 비동기 operations 을  observables 로 전환.</p>\n</li>\n<li>\n<p>Iterating through the values in a stream</p>\n</li>\n<li>\n<p>stream 값을 순회</p>\n</li>\n<li>\n<p>Mapping values to different types</p>\n</li>\n<li>\n<p>다른 타입에 대한 맵핑한 값</p>\n</li>\n<li>\n<p>Filtering streams</p>\n</li>\n<li>\n<p>스트림 필터링.</p>\n</li>\n<li>\n<p>Composing multiple streams</p>\n</li>\n<li>\n<p>multiple streams 의 생성</p>\n</li>\n</ul>\n<h2 id=\"observable-creation-functionsobservable-생성-함수들\">Observable creation functions(Observable 생성 함수들)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functionsobservable-생성-함수들\"><i class=\"material-icons\">link</i></a></h2>\n<p>RxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, promises, and so on. For example:</p>\n<p>RxJS는 새로운 observables을 생성하여 사용할수 있는 새로운 많은 수의 함수들을 제공한다. 그러한 함수들을 이벤트, timers, promises 등과 같이 것으로부터 observables의 생서의 과정을 간단하게 만든다. 예를 들면:</p>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" title=\"Create an observable from a promise\">\n\nimport { fromPromise } from 'rxjs/observable/fromPromise';\n\n// Create an Observable out of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> promise\n// promise 의 밖으로 Observable을 생성하라.\nconst data = fromPromise(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> result\n// 비동기 결과를 리스닝하는 것을 시작하는 구독하라.\ndata.subscribe({\n next(response) { console.log(response); },\n error(err) { console.error('Error: ' + err); },\n complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" title=\"Create an observable from a counter\">\n\nimport { interval } from 'rxjs/observable/interval';\n\n// Create an Observable that will publish <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> value on an interval\n// interval에서 값을 발행하는 Observable 을 생성하라. \n\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\n// 발행한 값을 구독하라. \nsecondsCounter.subscribe(n =>\n  console.log(`It's been ${n} seconds since subscribing!`));\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" title=\"Create an observable from an event\">\n\nimport { fromEvent } from 'rxjs/observable/fromEvent';\n\nconst el = document.getElementById('my-element');\n\n// Create an Observable that will publish mouse movements\n// 마우스 움직임들로 발행되는 Observable 을 생성하라.\nconst mouseMoves = fromEvent(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\n// 마우스 움직임 이벤트를 리스닝하도록 구독하라.\nconst subscription = mouseMoves.subscribe((evt: MouseEvent) => {\n  // Log coords of mouse movements\n  // 마우스 움직임들의 좌표를 로그로 찍어라.\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  // 화면에서 상-하로 움직힐때 , 마우스의 움직임 리스닝하는 것을 멈추기 위해서 구독해지하라.  \n  if (evt.clientX &#x3C; 40 &#x26;&#x26; evt.clientY &#x3C; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" title=\"Create an observable that creates an AJAX request\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\n\n// Create an Observable that will create an AJAX request\n// AJAX request 만드는  Observable을 생성하라.\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\n// 요청을 생성하기 위해서 구독하라.\napiData.subscribe(res => console.log(res.status, res.response));\n\n\n</code-example>\n<h2 id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2>\n<p>Operators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as <code>map()</code>, <code>filter()</code>, <code>concat()</code>, and <code>flatMap()</code>.</p>\n<p>Operators는 컬렉션의 정교한 조작을 가능하게 만드는 observables 기본을 이루는 함수들이다. 예를 들면, RxJS는 <code>map()</code>, <code>filter()</code>, <code>concat()</code>, 그리고 <code>flatMap()</code> 같은 operators룰 정의한다.</p>\n<p>Operators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable’s emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:</p>\n<p>Operators은 설정 옵션들을 가지고 , 본래의 observable을 가지는 함수들 리턴한다. 리턴된 함수를 실행할때, observes은  본래의 observable의 방출된 값을 관찰하고, 변형하고, 변형된 값으로 새로운 observable을 리턴한다. 여기 간단한 예가 있다:</p>\n<code-example path=\"rx-library/src/operators.ts\" title=\"Map operator\">\n\nimport { map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3);\n\nconst squareValues = map((val: number) => val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x => console.log(x));\n\n// Logs\n// 1\n// 4\n// 9\n\n\n</code-example>\n<p>You can use <em>pipes</em> to link operators together. Pipes let you combine multiple functions into a single function. The <code>pipe()</code> function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.</p>\n<p>당신은 operators를 함께 연결하기 위해서 <em>pipes</em> 를 사용할수 있다. Pipes는 multiple functions 을 single function으로 결합하도록 한다. <code>pipe()</code> function는 당신이 결합하길 원하는 함수들을 인자로 취하고 , 실행시에는 , 순차적으로 구성된 함수가 동작하는 새로운 함수를 리턴한다. </p>\n<p>A set of operators applied to an observable is a recipe—that is, a set of instructions for producing the values you’re interested in. By itself, the recipe doesn’t do anything. You need to call <code>subscribe()</code> to produce a result through the recipe.</p>\n<p>observable이 적용된 operators 의 묶음은 레시피이다; 즉, 당신이 관심이 있어하는 값을 생성하기 위한 명령어의 묶음이다. 이것 자체로는, 레시피는 어떤 것도 하지 않는다. 레시피를 통해서 결과를 생성하기 위해서 <code>subscribe()</code> 를 호출해야만 한다.</p>\n<p>Here’s an example:\n여기 그 예이다:</p>\n<code-example path=\"rx-library/src/operators.1.ts\" title=\"Standalone pipe function\">\n\nimport { pipe } from 'rxjs/util/pipe';\nimport { filter, map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3, 4, 5);\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> function that accepts an Observable.\n// Observable로 받아드린 함수를 생성한다.\nconst squareOddVals = pipe(\n  filter(n => n % 2),\n  map(n => n * n)\n);\n\n// Create an Observable that will run the filter and map functions\n// filter 그리고 map 함수를 실행 할 Observable을 생성하라.\nconst squareOdd = squareOddVals(nums);\n\n// Suscribe to run the combined functions\n// 조합된 함수가 실행되게 구독하라.\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<p>The <code>pipe()</code> function is also a method on the RxJS <code>Observable</code>, so you use this shorter form to define the same operation:</p>\n<p><code>pipe()</code> 함수는 또한 RxJS <code>Observable</code> 에 메서드이다, 그래서 당신은 같은 operation 을 정의하는것을 축약하여 형성할수 있다.</p>\n<code-example path=\"rx-library/src/operators.2.ts\" title=\"Observable.pipe function\">\n\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\n\nconst squareOdd = Observable.of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n => n % 2),\n    map(n => n * n)\n  );\n\n// Subscribe to get values\n// 깂을 얻기 위에 구독하라.\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<h3 id=\"common-operators\">Common operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3>\n<p>RxJS provides many operators (over 150 of them), but only a handful are used frequently. Here is a list of common operators; for usage examples, see  <a href=\"https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\">RxJS 5 Operators By Example</a> in RxJS documentation.</p>\n<p>RxJS는 많은 operators(150 이상으로)를 제공하지만, 오로지 몇 안되는 것들을 자주 사용할 것이다. 여기 공통적인 operators의 목록이다; RxJS 문서에서 사용의 예<a href=\"https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\">RxJS 5 Operators By Example</a>를 보라. </p>\n<div class=\"l-sub-section\">\n  Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.\n<p>  Angular 앱들을 위해서, 우리는 chaining 보다는 pipes 가지고 operator 결합하는 것을 선호한다. Chaining은 많은 RxJS 예에서 사용된다.</p>\n</div>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Area</th>\n<th align=\"left\">Operators</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Creation</td>\n<td align=\"left\"><code>from</code>\n, \n<code>fromPromise</code>\n,\n<code>fromEvent</code>\n, \n<code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\">Combination</td>\n<td align=\"left\"><code>combineLatest</code>\n, \n<code>concat</code>\n, \n<code>merge</code>\n, \n<code>startWith</code>\n , \n<code>withLatestFrom</code>\n, \n<code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\">Filtering</td>\n<td align=\"left\"><code>debounceTime</code>\n, \n<code>distinctUntilChanged</code>\n, \n<code>filter</code>\n, \n<code>take</code>\n, \n<code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\">Transformation</td>\n<td align=\"left\"><code>bufferTime</code>\n, \n<code>concatMap</code>\n, \n<code>map</code>\n, \n<code>mergeMap</code>\n, \n<code>scan</code>\n, \n<code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Utility</td>\n<td align=\"left\"><code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Multicasting</td>\n<td align=\"left\"><code>share</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"error-handling\">Error handling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p>In addition to the <code>error()</code> handler that you provide on subscription, RxJS provides the <code>catchError</code> operator that lets you handle known errors in the observable recipe.</p>\n<p>게다가 subscription 에 사용하는  <code>error()</code> handler 외에도 . RxJS는  observable recipe 에서 알려주는 에러들을 다루기 위한 <code>catchError</code> operator를 제공한다.</p>\n<p>For instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn’t exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.</p>\n<p>예를들면, API 요청을 하거나 서버로부터 응답을 발견하도록 하는 observable 을 가지고 추측해보다. 서버에서 에러나 값이 존재하지 않을 리턴한다면, 에러는 발생된다. 만약 이 에러를 잡아내거나 기본값을 제공한다면, stream은 에러를 제거하는 것보다는 값을 처리하는 것을 지속한다.</p>\n<p>Here's an example of using the <code>catchError</code> operator to do this:</p>\n<p>여기  <code>catchError</code> operator 사용하는 예시이다: </p>\n<code-example path=\"rx-library/src/error-handling.ts\" title=\"catchError operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, catchError } from 'rxjs/operators';\n// Return \"response\" from the API. If an error happens,\n// return an empty array.\n// API로부터 \"response\" 를 리턴하라. 만약 에러가 발생하면\n// 빈 객체를 반환한다.\n\nconst apiData = ajax('/api/data').pipe(\n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"retry-failed-observable\">Retry failed observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3>\n<p>Where the <code>catchError</code> operator provides a simple path of recovery, the <code>retry</code> operator lets you retry a failed request.</p>\n<p><code>catchError</code> operator 는 간단한 재개의 길을 제공하고 하는 영역이고,  <code>retry</code> operator는 실패된 요청을 재개하도록 하는것이다.</p>\n<p>Use the <code>retry</code> operator before the <code>catchError</code> operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.</p>\n<p><code>retry</code> operator 는 <code>catchError</code> operator 전에 사용하라. ,에러로 떨어진 모든 일렬의 동작들을 재개할수 있도록, 원래의 근원 observable 을 다시 재구독한다. 만약 이것이 HTTP 요청을 포함하고 있다면 , HTTP 요청을 재개할 것이다.</p>\n<p>The following converts the previous example to retry the request before catching the error:</p>\n<p>다음은 이전의 예시를 에러를 잡기전에 요청을 재개하는 예로 바꾸었다.</p>\n<code-example path=\"rx-library/src/retry-on-error.ts\" title=\"retry operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  retry(3), // Retry up to 3 times before failing\n            // 실패후에 3번 재개하라. \n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>   Do not retry <strong>authentication</strong> requests, since these should only be initiated by user action. We don't want to lock out user accounts with repeated login requests that the user has not initiated.</p>\n<p>  <strong>authentication</strong> 요청들은 재개하지 마라, 왜냐하면 유저의 행동에 의해서 재개되어야 하낟. 우리는 유저가 초기화하지 않은 반복되는 로그인을 요청하여 유저 계정이 잠기지 않길 바란다.</p>\n</div>\n<h2 id=\"naming-conventions-for-observables\">Naming conventions for observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a></h2>\n<p>Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing “$” sign.</p>\n<p>Angular applications 은 주로 타입스크립트로 작성되기 때문에, 당신으 일반적으로 변수가 observable 일때를 알고 있을것이다. 비록 Angular framework는 observables 에 대한 네이밍 컨벤션을 강요하지 않지만, 우리는 보통 “$” 표시가 달린 이름을 가진 observables을 종종 볼수 있다.</p>\n<p>This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the “$”.\nobservable 값을 찾거산 코드를 살펴볼때 아주 유용하다. 또한, 만약\nobservable 로부터 가장 최근 값을 속성으로 저장하길 원한다면,\n같은 이름에 “$” 있던 없던 간단하게 사용할수 있다.\nFor example :\n예시:</p>\n<code-example path=\"rx-library/src/naming-convention.ts\" title=\"Naming observables\">\n\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-stopwatch',\n  templateUrl: './stopwatch.component.html'\n})\nexport class StopwatchComponent {\n\n  stopwatchValue: number;\n  stopwatchValue$: Observable&#x3C;number>;\n\n  start() {\n    this.stopwatchValue$.subscribe(num =>\n      this.stopwatchValue = num\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/async\n - api/router/RouterLinkWithHref\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#naming-conventions-for-observables\n - guide/rx-library#observable-creation-functionsobservable-생성-함수들\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#the-rxjs-library\n - http://reactivex.io/rxjs/\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\n-->"
}