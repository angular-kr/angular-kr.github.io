{
  "id": "guide/lifecycle-hooks",
  "title": "Lifecycle Hooks",
  "contents": "\n<div class=\"content\">\n<h1 id=\"lifecycle-hooks\">Lifecycle Hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-hooks\"><i class=\"material-icons\">link</i></a></h1>\n<p>A component has a lifecycle managed by Angular.</p>\n<p>컴포넌트는 Angular에 의해서 lifecycle이 관리된다.</p>\n<p>Angular creates it, renders it, creates and renders its children,\nchecks it when its data-bound properties change, and destroys it before removing it from the DOM.</p>\n<p>앵귤러는 컴포넌트를 생성하고, 렌더링하고 , 컴포넌트의 자식까지 생성과 렌더링을 하고, data-bound 속성들이 변화할때를 체크하고, DOM으로부터 컴포넌트르 제거하기 전에 파괴한다. </p>\n<p>Angular offers <strong>lifecycle hooks</strong>\nthat provide visibility into these key life moments and the ability to act when they occur.</p>\n<p>Angular  핵심적인 주기의 순간에 대한 가시성을 주고,  생명주기가 발생시에 , 동작하는  있도록 해주는 능력을 주는  <strong>lifecycle hooks</strong>을 제공한다.</p>\n<p>A directive has the same set of lifecycle hooks.</p>\n<p>directive 하나의 lifecycle hooks 같은 주기를 가진다. </p>\n<a id=\"hooks-overview\"></a>\n<h2 id=\"component-lifecycle-hooks-overview\">Component lifecycle hooks overview<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle-hooks-overview\"><i class=\"material-icons\">link</i></a></h2>\n<p>Directive and component instances have a lifecycle\nas Angular creates, updates, and destroys them.\nDevelopers can tap into key moments in that lifecycle by implementing\none or more of the <em>lifecycle hook</em> interfaces in the Angular <code>core</code> library.</p>\n<p>Directive 그리고 component instances는 Angular가 생성,수정 그리고 제거하는 lifecycle 가진다. 개발자들은 Angular의 핵심 라이브러리의 <em>lifecycle hook</em> interfaces를 하나 또는 여러개 구현하는 방식으로  lifecycle의  key moments 활용할수 있다.</p>\n<p>Each interface has a single hook method whose name is the interface name prefixed with <code>ng</code>.\nFor example, the <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> interface has a hook method named <code>ngOnInit()</code>\nthat Angular calls shortly after creating the component:</p>\n<p>각각의 interface 는 <code>ng</code>를 앞에 단 interface 이름으로 붙여진 하나의 hook method 가진다.\n예를 들면,  <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> interface는  앵귤러가 컴포넌트 생성후에 짧은 호출하는<code>ngOnInit()</code>이라고 불리우는 hook method 메서드를 가진다.</p>\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" title=\"peek-a-boo.component.ts (excerpt)\" linenums=\"false\">\nexport class PeekABoo implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // implement <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>'s `ngOnInit` method\n  ngOnInit() { this.logIt(`<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>No directive or component will implement all of the lifecycle hooks.\nAngular only calls a directive/component hook method <em>if it is defined</em>.</p>\n<p>directive 또는 component는 모든  lifecycle hooks을 구현하지 않을 것이다.\nAngular 오로지 정의된만큼  directive/component hook method를 호출한다.</p>\n<a id=\"hooks-purpose-timing\"></a>\n<h2 id=\"lifecycle-sequence\">Lifecycle sequence<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-sequence\"><i class=\"material-icons\">link</i></a></h2>\n<p><em>After</em> creating a component/directive by calling its constructor, Angular\ncalls the lifecycle hook methods in the following sequence at specific moments:</p>\n<p>component/directive 의 생성자를  호출하면서 생성한후에 , Angular는 특정한 순간들에 순차적으로 lifecycle hook methods를 호출한다</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th>Hook</th>\n    <th>Purpose and Timing</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnChanges()</code>\n    </td>\n    <td>\n<p>      Respond when Angular (re)sets data-bound input properties.\nThe method receives a <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> object of current and previous property values.</p>\n<p>      Angular data-bound 입력 속성들을 (재)세팅할때 반응한다. 이 메서드는 현재와 이전의 속성 값들의 <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 객체 받는다.</p>\n<p>      Called before <code>ngOnInit()</code> and whenever one or more data-bound input properties change.</p>\n<p>      <code>ngOnInit()</code> 전에 호출되고 하나 또는 이상의 data-bound 입력 속성들이 변화가 있마다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnInit()</code>\n    </td>\n    <td>\n<p>      Initialize the directive/component after Angular first displays the data-bound properties\nand sets the directive/component's input properties.</p>\n<p>      Angular 처음에  data-bound 속성 표시한후에  directive/component 를 초기화하고\ndirective/component의 입력 속성을 세팅한다.</p>\n<p>      Called <em>once</em>, after the <em>first</em> <code>ngOnChanges()</code>.\n처음에 <code>ngOnChanges()</code> 후에, 한번 호출한다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngDoCheck()</code>\n    </td>\n    <td>\n<p>      Detect and act upon changes that Angular can't or won't detect on its own.</p>\n<p>      Angular가 스스로 감지할수 없거나 감지가 안되는 변화에 대해서 찾아내고 동작한다.</p>\n<p>      Called during every change detection run, immediately after <code>ngOnChanges()</code> and <code>ngOnInit()</code>.</p>\n<p>      <code>ngOnChanges()</code> and <code>ngOnInit()</code> 후에 즉각적으로 , 모든 변화 감지 일어나는 동안에 호출된다. </p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentInit()</code>\n    </td>\n    <td>\n<p>      Respond after Angular projects external content into the component's view / the view that a directive is in.</p>\n<p>       Angular projects 외부의 컨턴츠가 component/component 내부에 들어온후에 호출된다.</p>\n<p>      Called <em>once</em> after the first <code>ngDoCheck()</code>.\n최초 <code>ngDoCheck()</code> 후에 한번 호출된다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentChecked()</code>\n    </td>\n    <td>\n<p>      Respond after Angular checks the content projected into the directive/component.</p>\n<p>      Angular directive/component에 예상되는 컨턴츠를 확인후에 반응한다.</p>\n<p>      Called after the <code>ngAfterContentInit()</code> and every subsequent <code>ngDoCheck()</code>.\n<code>ngAfterContentInit()</code> 그리고 모든  <code>ngDoCheck()</code> 후에 호출된다. </p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewInit()</code>\n    </td>\n    <td>\n<p>      Respond after Angular initializes the component's views and child views / the view that a directive is in. </p>\n<p>      Angular는 component의 views 와 그 자식들의 views/ 디렉티브안에 view를 초기화 한후에 반응하다.</p>\n<p>      Called <em>once</em> after the first <code>ngAfterContentChecked()</code>.\n최초 <code>ngAfterContentChecked()</code> 후에 한번 호출된다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewChecked()</code>\n    </td>\n    <td>\n<p>      Respond after Angular checks the component's views and child views / the view that a directive is in.</p>\n<p>      Angular component의 views 와 그 자식들의 views/ 디렉티브안에 view를 확인한후에 반응한다.</p>\n<p>      Called after the <code>ngAfterViewInit</code> and every subsequent <code>ngAfterContentChecked()</code>.</p>\n<p>      <code>ngAfterViewInit</code> 그리고 모든 차후에 <code>ngAfterContentChecked()</code> 후에 호출된다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnDestroy()</code>\n    </td>\n    <td>\n<p>      Cleanup just before Angular destroys the directive/component.\nUnsubscribe Observables and detach event handlers to avoid memory leaks.</p>\n<p>      Angular는 directive/component 제거하고 오로지 클린한다.\nObservables 구독을 해지하고 , 메모리 누수를 피하기 위해서 이벤트 핸들러를 제거한다. </p>\n<p>      Called <em>just before</em> Angular destroys the directive/component.</p>\n<p>      Angular에서 directive/component 제거후에만 호출된다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"interface-optional\"></a>\n<h2 id=\"interfaces-are-optional-technically\">Interfaces are optional (technically)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#interfaces-are-optional-technically\"><i class=\"material-icons\">link</i></a></h2>\n<p>The interfaces are optional for JavaScript and Typescript developers from a purely technical perspective.\nThe JavaScript language doesn't have interfaces.\nAngular can't see TypeScript interfaces at runtime because they disappear from the transpiled JavaScript.</p>\n<p>interfaces는 자바스크립에서는 선택적이고, 타입 스크립트 개발자드을 순수하게 기술적인 관점에 보고있다.\n자바스크립트 언어는 interfaces 를 가지지 않는다.\nAngular는 트랜스 컴파일된 자바스크립트로 사라지기 때문에, TypeScript interfaces를 런타임 시점에서 볼수 없다. </p>\n<p>Fortunately, they aren't necessary.\nYou don't have to add the lifecycle hook interfaces to directives and components to benefit from the hooks themselves.</p>\n<p>운좋게도, 이건 필수적인게 아니다.\nhooks 하는 것으로 이득을 얻기 위해서, directives 그리고 components에 lifecycle hook interfaces 를 추가할 필요는 없다.</p>\n<p>Angular instead inspects directive and component classes and calls the hook methods <em>if they are defined</em>.\nAngular finds and calls methods like <code>ngOnInit()</code>, with or without the interfaces.</p>\n<p>Angular 대신에 directive 그리고 component classes를 조사하고 만약 정의 되었다면 the hook methods 호출한다.Angular는 interfaces가 없던지 있던지 간에 <code>ngOnInit()</code> 같은 메서드를 찾고 호출한다.</p>\n<p>Nonetheless, it's good practice to add interfaces to TypeScript directive classes\nin order to benefit from strong typing and editor tooling.\n그렇더라도, 타입스크립트의 interfaces 를 directive classes에 추가하는 것은 강한 타입핑과 에디터 툴림의 이점을 위해서는 가장 좋은 방법이다.</p>\n<a id=\"other-lifecycle-hooks\"></a>\n<h2 id=\"other-angular-lifecycle-hooks\">Other Angular lifecycle hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#other-angular-lifecycle-hooks\"><i class=\"material-icons\">link</i></a></h2>\n<p>Other Angular sub-systems may have their own lifecycle hooks apart from these component hooks.</p>\n<p>또다른 Angular 하위 시스템은 these component hooks과 분리하여 자신의 lifecycle hooks을 가질수 있다.</p>\n<p>3rd party libraries might implement their hooks as well in order to give developers more\ncontrol over how these libraries are used.</p>\n<p>3rd party libraries는 그들 자신만의 hook을 구현할뿐만 아니라  어떻게 그러한 라이브러리 사용되어야 하는지를 기반으로 하여 개발자들에 더 많은 제어를 할수 있도록 한다.</p>\n<a id=\"the-sample\"></a>\n<h2 id=\"lifecycle-examples\">Lifecycle examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-examples\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <live-example></live-example>\ndemonstrates the lifecycle hooks in action through a series of exercises\npresented as components under the control of the root <code>AppComponent</code>.</p>\n<p>루트 <code>AppComponent</code> 의 제어에서 컴포넌트로써 나타나는 연속적인 동작들을 통해서 lifecycle hooks 동작에 대해서 설명한다.</p>\n<p>They follow a common pattern: a <em>parent</em> component serves as a test rig for\na <em>child</em> component that illustrates one or more of the lifecycle hook methods.</p>\n<p>거기에는 공통적인 패턴을 따른다: <em>parent</em> component 는 하나 또는 여러개의 lifecycle hook methods 설명하는  a <em>child</em> component 를 위한 테스트 리그 로써 제공한다.</p>\n<p>Here's a brief description of each exercise:\n여기에 각각 예시에 대한 간단한 설명이 있다. </p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th>Component</th>\n    <th>Description</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a>\n    </td>\n    <td>\n<p>      Demonstrates every lifecycle hook.\nEach hook method writes to the on-screen log.</p>\n<p>      모든 every lifecycle hook 설명한다.\n각각의 화면의 로그로 hook method를 기록한다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#spy\">Spy</a>\n    </td>\n    <td>\n<p>      Directives have lifecycle hooks too.\nA <code>SpyDirective</code> can log when the element it spies upon is\ncreated or destroyed using the <code>ngOnInit</code> and <code>ngOnDestroy</code> hooks.</p>\n<p>      Directives 또한 lifecycle hooks을 가진다.\n<code>SpyDirective</code>는 <code>ngOnInit</code> 그리고 <code>ngOnDestroy</code> hooks 을 사용하여 엘리멘트가 생성 또는 소멸할대 로그화한다. </p>\n<p>      This example applies the <code>SpyDirective</code> to a <code>&#x3C;div></code> in an <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> <em>hero</em> repeater\nmanaged by the parent <code>SpyComponent</code>.</p>\n<p>      이 예시는 <code>SpyDirective</code>에  부모 pyComponent에 의해서 관리되게 </p><div> 안에 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 <em>hero</em> 반복자를 적용하였다.<p></p>\n    </div></td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a>\n    </td>\n    <td>\n<p>      See how Angular calls the <code>ngOnChanges()</code> hook with a <code>changes</code> object\nevery time one of the component input properties changes.\nShows how to interpret the <code>changes</code> object.</p>\n<p>      Angular가 어떻게 매순간마다 컴포넌트의 입력 속성 값이 변화시에 <code>changes</code> object 가지고  <code>ngOnChanges()</code> hook 호출하는지를 보라.\n어떻게 <code>changes</code> object를 해석하는지 보라.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a>\n    </td>\n    <td>\n<p>      Implements an <code>ngDoCheck()</code> method with custom change detection.\nSee how often Angular calls this hook and watch it post changes to a log.</p>\n<p>      커스텀 변화 감지를 가진 <code>ngDoCheck()</code> method는 구현한다.\n얼마나 자주 Angular 가 이 hook을 호출하는지를 보고 로그어 변화를 어떻게 보내는지도 보라.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#afterview\">AfterView</a>\n    </td>\n    <td>\n<p>      Shows what Angular means by a <em>view</em>.\nDemonstrates the <code>ngAfterViewInit</code> and <code>ngAfterViewChecked</code> hooks.</p>\n<p>      Angular에게 <em>view</em> 뜻하는 것이 무엇인지 보라.\n<code>ngAfterViewInit</code> and <code>ngAfterViewChecked</code> hooks을 설명한다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a>\n    </td>\n    <td>\n<p>      Shows how to project external content into a component and\nhow to distinguish projected content from a component's view children.\nDemonstrates the <code>ngAfterContentInit</code> and <code>ngAfterContentChecked</code> hooks.</p>\n<p>      어떻게 external content가 컴포넌트로 들어오는지와 a component's view 자식의 어떻게 들어오는 컨텐츠와 구분하는지르 보라. <code>ngAfterContentInit</code> 그리고<code>ngAfterContentChecked</code> hooks을 설명한다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      Counter\n    </td>\n    <td>\n<p>      Demonstrates a combination of a component and a directive\neach with its own hooks.</p>\n<p>      자식의 Hook을 가진 component 그리고 directive 의 조합을 설명한다.</p>\n<p>      In this example, a <code>CounterComponent</code> logs a change (via <code>ngOnChanges</code>)\nevery time the parent component increments its input counter property.\nMeanwhile, the <code>SpyDirective</code> from the previous example is applied\nto the <code>CounterComponent</code> log where it watches log entries being created and destroyed.</p>\n<p>      예를 들면,  <code>CounterComponent</code>는 매순간마다 부모 component가 입력 카운터 속성을 증가시키는 변화를 로그화 한다(<code>ngOnChanges</code> 통해서).\n그동안에, 이전 <code>SpyDirective</code> 의 예제에 <code>CounterComponent</code>의 시작과 생성됨과 제거됨으 감시하는 로그 적용한다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>The remainder of this page discusses selected exercises in further detail.</p>\n<a id=\"peek-a-boo\"></a>\n<h2 id=\"peek-a-boo-all-hooks\">Peek-a-boo: all hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#peek-a-boo-all-hooks\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>PeekABooComponent</code> demonstrates all of the hooks in one component.</p>\n<p><code>PeekABooComponent</code> 하나의 컴포넌트에서 모든 hooks 을 설명한다.</p>\n<p>You would rarely, if ever, implement all of the interfaces like this.\nThe peek-a-boo exists to show how Angular calls the hooks in the expected order.</p>\n<p>이것과 같이 모든 interfaces 를 거의 구현하지 것은 거의 없다.\npeek-a-boo 는 어떻게 앵규럴가 예상되는 순서에 따라서 hook을 호출하지를 보여주기 위해서 존재한다. </p>\n<p>This snapshot reflects the state of the log after the user clicked the <em>Create...</em> button and then the <em>Destroy...</em> button.</p>\n<p>이 스냅샷은 유저가 <em>Create...</em> 버튼을 누루거나 그리고 나서 <em>Destroy...</em> 을 버튼을 누룬후에 로그의 상태를 반영하다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\" width=\"309\" height=\"366\">\n</figure>\n<p>The sequence of log messages follows the prescribed hook calling order:\n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>, <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code>, <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> (3x), <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> (3x),\n<code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> (3x), and <code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code>.</p>\n<div class=\"l-sub-section\">\n<p>  The constructor isn't an Angular hook <em>per se</em>.\nThe log confirms that input properties (the <code>name</code> property in this case) have no assigned values at construction.</p>\n</div>\n<p>Had the user clicked the <em>Update Hero</em> button, the log would show another <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> and two more triplets of\n<code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> and <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code>.\nClearly these three hooks fire <em>often</em>. Keep the logic in these hooks as lean as possible!</p>\n<p>The next examples focus on hook details.</p>\n<a id=\"spy\"></a>\n<h2 id=\"spying-oninit-and-ondestroy\">Spying <em>OnInit</em> and <em>OnDestroy</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#spying-oninit-and-ondestroy\"><i class=\"material-icons\">link</i></a></h2>\n<p>Go undercover with these two spy hooks to discover when an element is initialized or destroyed.</p>\n<p>This is the perfect infiltration job for a directive.\nThe heroes will never know they're being watched.</p>\n<div class=\"l-sub-section\">\n<p>  Kidding aside, pay attention to two key points:</p>\n<ol>\n<li>\n<p>Angular calls hook methods for <em>directives</em> as well as components.<br><br></p>\n</li>\n<li>\n<p>A spy directive can provide insight into a DOM object that you cannot change directly.\nObviously you can't touch the implementation of a native <code>&#x3C;div></code>.\nYou can't modify a third party component either.\nBut you can watch both with a directive.</p>\n</li>\n</ol>\n</div>\n<p>The sneaky spy directive is simple, consisting almost entirely of <code>ngOnInit()</code> and <code>ngOnDestroy()</code> hooks\nthat log messages to the parent via an injected <code>LoggerService</code>.</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" title=\"src/app/spy.directive.ts\" linenums=\"false\">\n// Spy on any element to which it is applied.\n// Usage: &#x3C;div mySpy>...&#x3C;/div>\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[mySpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>You can apply the spy to any native or component element and it'll be initialized and destroyed\nat the same time as that element.\nHere it is attached to the repeated hero <code>&#x3C;div></code>:</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" title=\"src/app/spy.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" mySpy class=\"heroes\">\n  {{hero}}\n&#x3C;/div>\n\n</code-example>\n<p>Each spy's birth and death marks the birth and death of the attached hero <code>&#x3C;div></code>\nwith an entry in the <em>Hook Log</em> as seen here:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/spy-directive.gif\" alt=\"Spy Directive\" width=\"656\" height=\"378\">\n</figure>\n<p>Adding a hero results in a new hero <code>&#x3C;div></code>. The spy's <code>ngOnInit()</code> logs that event.</p>\n<p>The <em>Reset</em> button clears the <code>heroes</code> list.\nAngular removes all hero <code>&#x3C;div></code> elements from the DOM and destroys their spy directives at the same time.\nThe spy's <code>ngOnDestroy()</code> method reports its last moments.</p>\n<p>The <code>ngOnInit()</code> and <code>ngOnDestroy()</code> methods have more vital roles to play in real applications.</p>\n<a id=\"oninit\"></a>\n<h3 id=\"oninit\"><em>OnInit()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#oninit\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use <code>ngOnInit()</code> for two main reasons:\n<code>ngOnInit()</code>은 두가지 이유로 사용한다:</p>\n<ol>\n<li>To perform complex initializations shortly after construction.(생성후에 복잡한 초기화를 하기 위해서)</li>\n<li>To set up the component after Angular sets the input properties.(앵귤러가 입력 속성들을 세팅한 후에 컴포넌트를 준비하기 위해서)</li>\n</ol>\n<p>Experienced developers agree that components should be cheap and safe to construct.</p>\n<p>경험이 있는 개발자들은 컴포넌트는 저렴하고 생성시에 안전해야함에 동의한다.</p>\n<div class=\"l-sub-section\">\n<p>  Misko Hevery, Angular team lead,\n<a href=\"http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\">explains why</a>\nyou should avoid complex constructor logic.</p>\n</div>\n<p>Don't fetch data in a component constructor.\nYou shouldn't worry that a new component will try to contact a remote server\ncreated under test or before you decide to display it. Constructors should do no more than set the initial local variables to simple values.</p>\n<p>컴포넌트 생성자에서 데이터르 가져오지 마라. 새로운 컴포넌트 데스트로 생성된 원격 서버를 접속하려고 하는것과 이것을 화면에 보이지 전에는 걱정하지마라.\n생성자는 초기 로컬 변수를 간단한 값을 세팅하는 이상으로 하지마라. </p>\n<p>An <code>ngOnInit()</code> is a good place for a component to fetch its initial data. The\n<a href=\"tutorial/toh-pt4#oninit\">Tour of Heroes Tutorial</a> guide shows how.</p>\n<p><code>ngOnInit()</code>는 컴포넌트가 초기 데이터를 가져오기 위한 좋은 장소이다. <a href=\"tutorial/toh-pt4#oninit\">Tour of Heroes Tutorial</a> 가이드는 방법을 보여주고 있다.</p>\n<p>Remember also that a directive's data-bound input properties are not set until <em>after construction</em>.\nThat's a problem if you need to initialize the directive based on those properties.\nThey'll have been set when <code>ngOnInit()</code> runs.</p>\n<p>directive의 data-bound 입력 속성은 생성후에도 세팅되지 않는 것을 기억하라.</p>\n<p>만약 directive 그러한 속성에 근거하여 초기화 하는 것이 필요로 한다면 이건 문제가 있다. <code>ngOnInit()</code> 동작할때, 그것들이 세팅되어 질것이다.</p>\n<div class=\"l-sub-section\">\n<p>  The <code>ngOnChanges()</code> method is your first opportunity to access those properties.\nAngular calls <code>ngOnChanges()</code> before <code>ngOnInit()</code> and many times after that.\nIt only calls <code>ngOnInit()</code> once.</p>\n<p>  <code>ngOnChanges()</code> method 는 처음 그러한 속성들을 접근할 기회이다.\nAngular는  <code>ngOnInit()</code> 전에 <code>ngOnChanges()</code> 호출하고 그리고 이것 후에 매번 호출한다.</p>\n</div>\n<p>You can count on Angular to call the <code>ngOnInit()</code> method <em>soon</em> after creating the component.\nThat's where the heavy initialization logic belongs.</p>\n<p>컴포넌트가 생성된 후에 <code>ngOnInit()</code> method 가 곧 앵귤러 호출됨을 셀수 있다.\n여기에는 무거운 생성 로직을 포함한 곳이다.</p>\n<a id=\"ondestroy\"></a>\n<h3 id=\"ondestroy\"><em>OnDestroy()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ondestroy\"><i class=\"material-icons\">link</i></a></h3>\n<p>Put cleanup logic in <code>ngOnDestroy()</code>, the logic that <em>must</em> run before Angular destroys the directive.</p>\n<p>Angular 가 directive 제거하기 전에 동작해야할 제거 로직을 <code>ngOnDestroy()</code> 안에 놓는다.</p>\n<p>This is the time to notify another part of the application that the component is going away.</p>\n<p>이것은 컴포넌트가 사라진다는것을 어플리케이션의 또다른 부분에 알리는 위한 시간입니다.</p>\n<p>This is the place to free resources that won't be garbage collected automatically.\nUnsubscribe from Observables and DOM events. Stop interval timers.\nUnregister all callbacks that this directive registered with global or application services.\nYou risk memory leaks if you neglect to do so.</p>\n<p>garbage collecteed 자동적으로 되지 않는 자원을 해체하기 위한 장소입니다.\nObservables 그리고 DOM events를 구독해지합니다. interval timers를 멈추어라.\n전역 또는 어플리케이션으로 이 디렉티브에 등록된 모든 콜백들을 해지하라.\n만약 이 이를 무시란다면 메모리 부족해진다.</p>\n<a id=\"onchanges\"></a>\n<h2 id=\"onchanges\"><em>OnChanges()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#onchanges\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular calls its <code>ngOnChanges()</code> method whenever it detects changes to <strong><em>input properties</em></strong> of the component (or directive).\nThis example monitors the <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> hook.</p>\n<p>앵귤러는 컴포넌트(또는 디렉티브)의 <strong><em>input properties</em></strong> 의 변화를 감지할때마다  <code>ngOnChanges()</code> method 호출한다.\n이 예제는  <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 을 감지하는 것이다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" title=\"on-changes.component.ts (excerpt)\" linenums=\"false\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (let propName in changes) {\n    let chng = changes[propName];\n    let cur  = JSON.stringify(chng.currentValue);\n    let prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p>The <code>ngOnChanges()</code> method takes an object that maps each changed property name to a\n<a href=\"api/core/SimpleChange\">SimpleChange</a> object holding the current and previous property values.\nThis hook iterates over the changed properties and logs them.</p>\n<p><code>ngOnChanges()</code> method는 각각의 변화 속성명으로 현재와 이전 속성 값을 가진<a href=\"api/core/SimpleChange\">SimpleChange</a> 객체로 맵핑된 객체를 가진다.\n이 hook 변화된 값들을 순회하고 그것들을 로그화한다.</p>\n<p>The example component, <code>OnChangesComponent</code>, has two input properties: <code>hero</code> and <code>power</code>.</p>\n<p>예시에 <code>OnChangesComponent</code> 컴포넌트는 2개의 입력 값을 가진다: <code>hero</code> 그리고 <code>power</code>. </p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" title=\"src/app/on-changes.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power: string;\n\n</code-example>\n<p>The host <code>OnChangesParentComponent</code> binds to them like this:\n주인인 <code>OnChangesParentComponent</code>는 이것과 같이 묶는다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" title=\"src/app/on-changes-parent.component.html\">\n&#x3C;on-changes [hero]=\"hero\" [power]=\"power\">&#x3C;/on-changes>\n\n</code-example>\n<p>Here's the sample in action as the user makes changes.\n여기 유저가 만드는 변화로 동작하는 같은 예시가 있다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" alt=\"OnChanges\" width=\"632\" height=\"512\">\n</figure>\n<p>The log entries appear as the string value of the <em>power</em> property changes.\nBut the <code>ngOnChanges</code> does not catch changes to <code>hero.name</code>\nThat's surprising at first.</p>\n<p>로그 시작은  <em>power</em> 속서의 변화에 대한 문자열 값으로 나타난다. 하지만\n<code>ngOnChanges</code>은 <code>hero.name</code>의 변화를 잡아내지 않는다.\n이것은 처음으로 놀라운 것이다.</p>\n<p>Angular only calls the hook when the value of the input property changes.\nThe value of the <code>hero</code> property is the <em>reference to the hero object</em>.\nAngular doesn't care that the hero's own <code>name</code> property changed.\nThe hero object <em>reference</em> didn't change so, from Angular's perspective, there is no change to report!</p>\n<p>Angular는 오직  입력 속성 값의 변화 할때 , hook 호출한다.  <code>hero</code> property 의 값은 hero object의 참조이다.\nAngular는 hero's 자신의 <code>name</code>속성 변화를 잡아내지 않는다. The hero object 참조는 변화가 아니므로, 앵귤러 관점에서는 , 알려야 할 변화가 없다.</p>\n<a id=\"docheck\"></a>\n<h2 id=\"docheck\"><em>DoCheck()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#docheck\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use the <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> hook to detect and act upon changes that Angular doesn't catch on its own.</p>\n<p>앵귤러 자체에서 잡을수 없는 변화를 감지하고 ,대응하기 위해서 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> hook을 사용하라.  </p>\n<div class=\"l-sub-section\">\n<p>  Use this method to detect a change that Angular overlooked.\n앵귤러가 간과하는 변화를 찾기 위해서 이 메소드를 사용하라.</p>\n</div>\n<p>The <em>DoCheck</em> sample extends the <em>OnChanges</em> sample with the following <code>ngDoCheck()</code> hook:</p>\n<p> <em>DoCheck</em>은 <em>OnChanges</em> 샘플에 <code>ngDoCheck()</code> hook 가진  간단한 확장이다.</p>\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" title=\"DoCheckComponent (ngDoCheck)\" linenums=\"false\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      let count = this.noChangeCount += 1;\n      let noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p>This code inspects certain <em>values of interest</em>, capturing and comparing their current state against previous values.\nIt writes a special message to the log when there are no substantive changes to the <code>hero</code> or the <code>power</code>\nso you can see how often <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> is called. The results are illuminating:</p>\n<p>이 코드는 이전값과 대비하여 현재 값을 비교하거나 잡아내어 어떤 값의 변화에 대해서 조사하고 있다.</p>\n<p>이것은  <code>hero</code> 또는 <code>power</code> 에 실질적인 변화가 없을때도 로그에 특별한 메서지로 작성했다 그래서 우리는 얼마나 자주  <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>를 호출하고 있는지 볼수있다. 그 예시를 들고있다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" alt=\"DoCheck\" width=\"632\" height=\"588\">\n</figure>\n<p>While the <code>ngDoCheck()</code> hook can detect when the hero's <code>name</code> has changed, it has a frightful cost.\nThis hook is called with enormous frequency—after <em>every</em>\nchange detection cycle no matter where the change occurred.\nIt's called over twenty times in this example before the user can do anything.</p>\n<p><code>ngDoCheck()</code> hook은 hero의 <code>name</code> 변화 될때 찾을후 있는 반면에, 이것은 끔직한 비용이다.\n이 hook은 막대하게 빈번하게 호출한다. 모든 변화 감지는 변화가 발생한 것과 상관없이 돌아간 후에.\n이것은 예시에서 유저가 어떤것도 하기전에 20번 이상 호출된다. </p>\n<p>Most of these initial checks are triggered by Angular's first rendering of <em>unrelated data elsewhere on the page</em>.\nMere mousing into another <code>&#x3C;input></code> triggers a call.\nRelatively few calls reveal actual changes to pertinent data.\nClearly our implementation must be very lightweight or the user experience suffers.</p>\n<p>대부분의 그러한 초기 체크는 Angular의 초기 페이지에서 연관되지 않는 데이터의 렌더링은 의해서 발생된다. 겨우 또다른 <code>&#x3C;input></code> 의 마우스질을 호출을 발동시킨다.\n비교적 거의 적적한 데이터의 실제 변화들은 나타나지 않는다.\n명백하게 우리의 구현은 가벼워야 하고 유저 경험 겪어야 한다.</p>\n<a id=\"afterview\"></a>\n<h2 id=\"afterview\">AfterView<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#afterview\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <em>AfterView</em> sample explores the <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> and <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> hooks that Angular calls\n<em>after</em> it creates a component's child views.</p>\n<p><em>AfterView</em> sample 은 컴포넌트의 자식 views 가 생성된후에 앵귤러가 호출하는 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 그리고 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>를 살펴본다. </p>\n<p>Here's a child view that displays a hero's name in an <code>&#x3C;input></code>:</p>\n<p>이것 <code>&#x3C;input></code>의  hero's name을 보여주는 자식 view 이다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" title=\"ChildComponent\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: '&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">'\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p>The <code>AfterViewComponent</code> displays this child view <em>within its template</em>:</p>\n<p><code>AfterViewComponent</code>는 이 템플릿 안에서 자식 views 를 보여준다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" title=\"AfterViewComponent (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;div>-- child view begins --&#x3C;/div>\n    &#x3C;app-child-view>&#x3C;/app-child-view>\n  &#x3C;div>-- child view ends --&#x3C;/div>`\n\n</code-example>\n<p>The following hooks take action based on changing values <em>within the child view</em>,\nwhich can only be reached by querying for the child view via the property decorated with\n<a href=\"api/core/ViewChild\">@ViewChild</a>.</p>\n<p>다음 Hook은 자식 view의 변화하는 값을 근거한 동작을 취한다, 이것은 <a href=\"api/core/ViewChild\">@ViewChild</a>  테코레이터를 통해서 자식 view에 대해서 질의 함으써로 도달될수 있다. </p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" title=\"AfterViewComponent (class excerpts)\" linenums=\"false\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> VIEW child of type `ChildViewComponent`\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"wait-a-tick\"></a>\n<h3 id=\"abide-by-the-unidirectional-data-flow-rule단방향-데이터-흐름-규칙에-의해서-견뎌라-\">Abide by the unidirectional data flow rule(단방향 데이터 흐름 규칙에 의해서 견뎌라. )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#abide-by-the-unidirectional-data-flow-rule단방향-데이터-흐름-규칙에-의해서-견뎌라-\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>doSomething()</code> method updates the screen when the hero name exceeds 10 characters.</p>\n<p>hero name 이 10 글자 초과 할때, <code>doSomething()</code>는  method 는 화면을 수정한다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" title=\"AfterViewComponent (doSomething)\" linenums=\"false\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  let c = this.viewChild.hero.length > 10 ? `That's <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> long name` : '';\n  if (c !== this.comment) {\n    // Wait <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}\n\n</code-example>\n<p>Why does the <code>doSomething()</code> method wait a tick before updating <code>comment</code>?</p>\n<p>왜 <code>doSomething()</code> method는 <code>comment</code> 를 변경하기 전에 잠시 대기하는 걸까?</p>\n<p>Angular's unidirectional data flow rule forbids updates to the view <em>after</em> it has been composed.\nBoth of these hooks fire <em>after</em> the component's view has been composed.</p>\n<p>앵귤러의 단방향성 데이터 흐름의 규칙은 , 이것이 구성된 후에 view를 변경하는것을 금지한다.\n각각의 그러한 hooks은 component의 views 가 구성된후에 동작한다.</p>\n<p>Angular throws an error if the hook updates the component's data-bound <code>comment</code> property immediately (try it!).\nThe <code>LoggerService.tick_then()</code> postpones the log update\nfor one turn of the browser's JavaScript cycle and that's just long enough.</p>\n<p>앵귤러를 만약 data-bound <code>comment</code>의 속성이 즉시 수정되면 컴포넌트의 에러를 던진다(해보자). <code>LoggerService.tick_then()</code>는 브라우저의 자바스크립트 사이틀의 한 주기를 지연으로 하여 로그의 수정을 연기한다. 이것은 너무 길지는 않다.</p>\n<p>Here's <em>AfterView</em> in action:\n여기 <em>AfterView</em> 동작의 예이다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" alt=\"AfterView\" width=\"520\" height=\"532\">\n</figure>\n<p>Notice that Angular frequently calls <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>, often when there are no changes of interest.\nWrite lean hook methods to avoid performance problems.</p>\n<p>앵귤러는 빈번하게 어떤 변화가 없을때 , <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 호출함을 주의하라.\n성능 문제들을 피하기 위해서 hook methods 에 의존하여 써라.</p>\n<a id=\"aftercontent\"></a>\n<h2 id=\"aftercontent\">AfterContent<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <em>AfterContent</em> sample explores the <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> and <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> hooks that Angular calls\n<em>after</em> Angular projects external content into the component.</p>\n<p><em>AfterContent</em> sample은 앵굴러가 컴포넌트에 외부 컨텐츠를 보여준후에 호출되는 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> 그리고 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> hooks들을  살펴본다. </p>\n<a id=\"content-projection\"></a>\n<h3 id=\"content-projection\">Content projection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#content-projection\"><i class=\"material-icons\">link</i></a></h3>\n<p><em>Content projection</em> is a way to import HTML content from outside the component and insert that content\ninto the component's template in a designated spot.</p>\n<p><em>Content projection</em> 는 외부 컴포넌트의 HTML 을  import 하고, 설계한 영역에서 컴포넌트의 템플릿을 컨텐츠를 삽입하는 방법이다.</p>\n<div class=\"l-sub-section\">\n<p>  AngularJS developers know this technique as <em>transclusion</em>.</p>\n</div>\n<p>Consider this variation on the <a href=\"guide/lifecycle-hooks#afterview\">previous <em>AfterView</em></a> example.\nThis time, instead of including the child view within the template, it imports the content from\nthe <code>AfterContentComponent</code>'s parent. Here's the parent's template:</p>\n<p><a href=\"guide/lifecycle-hooks#afterview\">previous <em>AfterView</em></a>의 예시의 변화를 고려하라.\n이번에는, 템플릿 안에서 자식 view를 포함시키는 대신에, <code>AfterContentComponent</code>의 부모에게 이것을 컨텐츠로 import 하라. 여기 그 부모템플릿 예이다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" title=\"AfterContentParentComponent (template excerpt)\" linenums=\"false\">\n`&#x3C;after-content>\n   &#x3C;app-child>&#x3C;/app-child>\n &#x3C;/after-content>`\n\n</code-example>\n<p>Notice that the <code>&#x3C;my-child></code> tag is tucked between the <code>&#x3C;after-content></code> tags.\nNever put content between a component's element tags <em>unless you intend to project that content into the component</em>.</p>\n<p><code>&#x3C;my-child></code> tag는 <code>&#x3C;after-content></code> tag 의 사이에 갇혀 있음을 주목하라.\n컴포넌트로 컨테츠를 표시하는것을 의도하는 것 업신느 a component의 element tags 사이에 컨텐츠를 두지마라.</p>\n<p>Now look at the component's template:</p>\n<p>지금 컴포넌트의 템플릿을 보라:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" title=\"AfterContentComponent (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;div>-- projected content begins --&#x3C;/div>\n    &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;div>-- projected content ends --&#x3C;/div>`\n\n</code-example>\n<p>The <code>&#x3C;ng-content></code> tag is a <em>placeholder</em> for the external content.\nIt tells Angular where to insert that content.\nIn this case, the projected content is the <code>&#x3C;my-child></code> from the parent.\n<code>&#x3C;ng-content></code> tag 는 외부의 컨텐츠를 위한  <em>placeholder</em>이다.\n이것은 컨턴츠를 삽입할 영역을 앵귤러에 알려준다.\n이런 경우에, 표시된 컨턴트츠는 부모로부터  <code>&#x3C;my-child></code>이다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" alt=\"Projected Content\" width=\"230\" height=\"89\">\n</figure>\n<div class=\"l-sub-section\">\n<p>  The telltale signs of <em>content projection</em> are twofold:\n<em>content projection</em>의 숨길수 없는 표시들은 이중적이다.</p>\n<ul>\n<li>HTML between component element tags.(컴포넌트 엘리멘트 태그 사이의 HTML)</li>\n<li>The presence of <code>&#x3C;ng-content></code> tags in the component's template.(컴포넌트 템플릿 안에 <code>&#x3C;ng-content></code> 의 존재)</li>\n</ul>\n</div>\n<a id=\"aftercontent-hooks\"></a>\n<h3 id=\"aftercontent-hooks\">AfterContent hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent-hooks\"><i class=\"material-icons\">link</i></a></h3>\n<p><em>AfterContent</em> hooks are similar to the <em>AfterView</em> hooks.\nThe key difference is in the child component.</p>\n<p><em>AfterContent</em> hooks은  <em>AfterView</em> hooks 와 비슷하다.\n핵심 차리점은 자식 컴포넌트에 있다.</p>\n<ul>\n<li>The <em>AfterView</em> hooks concern <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, the child components whose element tags\nappear <em>within</em> the component's template.</li>\n</ul>\n<p><em>AfterView</em> hooks은  컴포넌트의 템플릿 이내에서 나타나는 엘리멘트에 자식 컨포넌트 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>하고 연관된다.</p>\n<ul>\n<li>The <em>AfterContent</em> hooks concern <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>, the child components that Angular\nprojected into the component.</li>\n</ul>\n<p><em>AfterContent</em> hooks 앵귤러가 컴포넌트에서 나타나는 하는 자식 컴포넌트인 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>과 연관된다.</p>\n<p>The following <em>AfterContent</em> hooks take action based on changing values in a <em>content child</em>,\nwhich can only be reached by querying for them via the property decorated with\n<a href=\"api/core/ContentChild\">@ContentChild</a>.</p>\n<p>여기에서는 <em>AfterContent</em> hooks 은  <a href=\"api/core/ContentChild\">@ContentChild</a>로 데코레이트 된 속성을 통해서 질의하여 결정되는 <em>content child</em>에 변경되는 값에 의해서 동작한다. </p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" title=\"AfterContentComponent (class excerpts)\" linenums=\"false\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> CONTENT child of type `ChildComponent`\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"no-unidirectional-flow-worries\"></a>\n<h3 id=\"no-unidirectional-flow-worries-with-aftercontent단방향의-흐름에서-aftercontent-신경쓰지-않아도-된다-\">No unidirectional flow worries with <em>AfterContent</em>(단방향의 흐름에서 <em>AfterContent</em> 신경쓰지 않아도 된다. )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#no-unidirectional-flow-worries-with-aftercontent단방향의-흐름에서-aftercontent-신경쓰지-않아도-된다-\"><i class=\"material-icons\">link</i></a></h3>\n<p>This component's <code>doSomething()</code> method update's the component's data-bound <code>comment</code> property immediately.\nThere's no <a href=\"guide/lifecycle-hooks#wait-a-tick\">need to wait</a>.</p>\n<p>이 컴포넌트의 <code>doSomething()</code> method는 컴포넌트의 data-bound <code>comment</code> property을 즉시 변경한다.\n기다릴 필요가 없다.<a href=\"guide/lifecycle-hooks#wait-a-tick\">need to wait</a>.</p>\n<p>Recall that Angular calls both <em>AfterContent</em> hooks before calling either of the <em>AfterView</em> hooks.\nAngular completes composition of the projected content <em>before</em> finishing the composition of this component's view.\nThere is a small window between the <code>AfterContent...</code> and <code>AfterView...</code> hooks to modify the host view.</p>\n<p>Angular는 <em>AfterView</em> hooks을 호출하기전에 각각의 <em>AfterContent</em> hooks을 호출함을 기억하세요.\nAngular는 컴포넌트의 views의 조합이 완료되기 전에, 나타내는 컨턴츠의 조합을 완료한다.\nthe host view 를 수정하기 위해서 <code>AfterContent...</code> 그리고 <code>AfterView...</code> hooks 사이에 작은 창 있다.</p>\n\n</div>\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - guide/architecture\n - guide/change-log\n - guide/component-interaction\n - guide/glossary\n - guide/reactive-forms\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt1\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/DoCheck\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Query\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/testing/tick\n - api/forms/NgModel\n - api/router/RouterLinkWithHref\n - guide/lifecycle-hooks#abide-by-the-unidirectional-data-flow-rule단방향-데이터-흐름-규칙에-의해서-견뎌라-\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#aftercontent-hooks\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#component-lifecycle-hooks-overview\n - guide/lifecycle-hooks#content-projection\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#interfaces-are-optional-technically\n - guide/lifecycle-hooks#lifecycle-examples\n - guide/lifecycle-hooks#lifecycle-hooks\n - guide/lifecycle-hooks#lifecycle-sequence\n - guide/lifecycle-hooks#no-unidirectional-flow-worries-with-aftercontent단방향의-흐름에서-aftercontent-신경쓰지-않아도-된다-\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#other-angular-lifecycle-hooks\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#peek-a-boo-all-hooks\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#spying-oninit-and-ondestroy\n - guide/lifecycle-hooks#wait-a-tick\n - tutorial/toh-pt4#oninit\n - http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\n-->"
}